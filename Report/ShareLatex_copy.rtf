{\rtf1\ansi\ansicpg1252\cocoartf1347\cocoasubrtf570
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0 \\documentclass[a4paper, 10pt]\{report\}\
\
\\usepackage\{listings\}\
\\usepackage\{color\}\
\\usepackage[table]\{xcolor\}\
\\usepackage[plain]\{algorithm\}\
\\usepackage\{algpseudocode\}\
%\\usepackage\{algorithm2e\}\
\\usepackage\{amssymb,amsmath,amsthm\}\
\\usepackage\{graphicx\}\
\\usepackage[backend=bibtex]\{biblatex\}\
\\usepackage\{textcomp\}\
\\usepackage\{microtype\}\
\\usepackage\{caption,subcaption\}\
\\usepackage\{tabularx\}\
%\\usepackage\{tikz\}\
\\usepackage\{hyperref\}\
\\hypersetup\{\
    %colorlinks=black, % make the links colored\
    %linkcolor=black, % color TOC links in black\
    %urlcolor=black, % color URLs in black\
    linktoc=all % 'all' will create links for everything in the TOC\
\}\
\
\\addbibresource\{references.bib\}\
\
%\\setlength\{\\parskip\}\{\\baselineskip\}%\
%\\setlength\{\\parindent\}\{0pt\}%\
\
\\linespread\{1.3\}\
\
\\newcommand\{\\tabitem\}\{~~\\llap\{\\textbullet\}~~\}\
\
\\definecolor\{dkgreen\}\{rgb\}\{0,0.6,0\}\
\\definecolor\{gray\}\{rgb\}\{0.5,0.5,0.5\}\
\\definecolor\{mauve\}\{rgb\}\{0.58,0,0.82\}\
\
\\definecolor\{pred\}\{rgb\}\{0.9,0,0\}\
\
\\definecolor\{javared\}\{rgb\}\{0.6,0,0\} % for strings\
\\definecolor\{javagreen\}\{rgb\}\{0.25,0.5,0.35\} % comments\
\\definecolor\{javapurple\}\{rgb\}\{0.5,0,0.35\} % keywords\
\\definecolor\{javadocblue\}\{rgb\}\{0.25,0.35,0.75\} % javadoc\
\
\\lstset\{frame=tb,\
  language=Java,\
  aboveskip=3mm,\
  belowskip=3mm,\
  showstringspaces=false,\
  columns=flexible,\
  basicstyle=\{\\small\\ttfamily\},\
  numbers=none,\
  numberstyle=\\tiny\\color\{gray\},\
  keywordstyle=\\color\{javapurple\},\
  commentstyle=\\color\{javagreen\},\
  stringstyle=\\color\{blue\},\
  breaklines=true,\
  breakatwhitespace=true,\
  tabsize=2,\
  basicstyle=\\tiny\
\}\
\
\
\\title\{Master Thesis\}% \\\\ \\vspace\{2 mm\} \{\\large Group 4\}\}\
\\author\{\
    Rusvik, Johan Alexander\\\\\
    \\texttt\{johan.rusvik@student.uib.no\}\
\}\
\\date\{10.11.2014\}\
\
\\begin\{document\}\
\
\\maketitle\
\
\\newpage\
\\tableofcontents\
\
\\newpage\
\\listoffigures\
\
\\newpage\
\\listoftables\
\
\\newpage\
\\listofalgorithms\
\
\\newpage\
\\chapter\{Introduction\}\
\
\\section\{Motivation and background\}\
Noone can reject that instant communication and push messages through smart phones are becoming more and more a part of our society. The number of devices connected to the cellular network is increasing and the demand for good reception is growing. In urban areas the general citizen might get frustrated if she is only disconnected from the network unwillingly for just a second. It is even expected to be able to surf the internet inside car tunnels made of concrete, or make phone calls below the ground while riding the subway. But how is this possible? To communicate with the outside world through the cell phone requires the phone to be connected to the cellular network, which means it needs to receive a signal from somewhere. These signals originates from antennas that are placed all over the world. How many antennas are there and where are they located?\
\
There are several internet sites that attempts to answer this question. For example \\textit\{opensignal.com\}, \\textit\{cellmapper.net\} and \\textit\{opencellid.org\}. Their goal is to show exactly where the antennas that broadcasts cell signals are located. They provide quite accurate location of antennas but not exact, at least in most cases. What makes this goal difficult to accomplish is that the cellular network providers in most countries are not obliged to provide data about the location of the antennas. So how can these sites know where the antennas are located? The answer is crowdsourcing. The sites provide smart phone applications the users can download that gathers data about the antenna the phone is connected to, and transmits the data to a database. Based on this data the sites attempt to position the antennas.\
\
OpenCellID \\cite\{opencellid\} is the worlds largest collaborative community project for collecting GPS positions of cellular network antennas. As of August 2014, their database contained more than 6 million unique antennas and 1 Billion crowdsourced measurements. The algorithm used by opencellid to calcule the positions of antennas is very simple. Based on the measurements belonging to an antenna, the position of the antenna is set to be the mean of those measurements' longitude and latitude. This is not a good approach since antennas broadcast their signals in the shape of a pizza slize, usually $120^\{\\circ\}$ horizontally, and not $360^\{\\circ\}$. This means most antennas will be put somewhere in the middle among its measurements, when it should be put somewhere so that every measurement lies to some direction of the antenna.\
\
When we look at the map this error in antenna position might not be that significant. We can still get a good idea of how many antennas are in a certain area, and approximately where they are located. But out on the street, in a more practical sense, it is more significant. If a person is interested in knowing how many antennas are close to his appartement, work place or regular drinking hole, an error of 100 meters is a significant distance. She might only be interested in the antennas that are within a radius of 50 meters. But 100 meters, 1,000 meters, or even 5,000 meters might look like nothing on a map, especially when low scaling is possible.\
\
Why do a person want to know where antennas are located? The answer is radiation. To compensate for high buildings and other types of infrastructure in urban areas there has to be loads of antennas broadcasting signals. In addition, the coverage areas of antennas has to overlap so our calls are not suddenly interrupted or streaming of videos are not cut of. This means there are a lot of signals flying around town. Researchers claim that these signals are harmless, but should not everyone be able to decide for themselves if they want to work or live nearby these antennas? Many peoply die of reasons that can not be explained. Infants are born with deseases or with a hand with only four fingers on it. Drugs and alcohol are not always to blame, so can the reason be the different kinds of radiation we are exposed to every day?\
\
%Erstatning for GPS?\
\
\\textit\{Enten her eller under Related Work vil jeg skrive mer om hva eksakte cell tower posisjoner kan brukes til. Jeg tenker paa posisjonering av mobile enheter som et alternativ til GPS. Fordelene er energisparing, samt funksjonalitet naar GPS ikke er tilgjengelig. I tillegg kan man finne den beste nettverksleverandoeren der man oppholder seg mye.\}\
\
\\section\{Research questions\}\
With this thesis we want to briefly identify the work that has previously been done when it comes to positioning cellular network antennas. We want to find out if it possible to implement, test and possibly improve existing solutions with regard to the problem OpenCellID is faced with, namely their simple algorithm for positioning antennas. If not, we want to develop our own process for positioning the antennas. We want to base our conclusions on generated theoretical testdata, and real data provided by OpenCellID.\
\
\\section\{Fundamental terminology\}\
We now define some fundamental terminology. Other nontrivial terminolgy will be explained throughout the thesis.\
\
\\subsection\{Cell\} A \\textit\{cell\} is a geographic area that is covered by a cellular network antenna. The signal originating from this antenna can potentially reach every mobile host within the area covered by the cell \\cite[p.~548]\{computernetworking\}. The antenna is placed on a \\textit\{cell tower\}, or more generally a base station. From now on we will refer to a cellular network antenna as a cell tower. We will refer to the coverage area of a cell as the \\textit\{cell sector\}, the angle of the cell sector as the \\textit\{sector angle\}, and the edges of the cell sector as the \\textit\{cell edges\}.\
\
The sector angle is with few exceptions always approximately $120^\{\\circ\}$. Some cellular network operators use cells where the sector angle is smaller, for example approximately $60^\{\\circ\}$, in areas where it is more practical, for example in urban areas. It is normal that three or more cells share a cell tower to cover everything in a $360^\{\\circ\}$ angle around the cell tower. The cell tower will then have several antennas pointing in different directions.\
\
To avoid disconnection and support high demand, the cells and cell towers are in theory orginized as shown in figure \\ref\{cell_network\}. We can think of it as a system of hexagons where each hexagon is covered by at least three different cells. Depending on the power of the antenna it may cover more than its own hexagon. This ensures efficient overlapping and constant connection to the cellular network for the users.\
\
We will also consider a cell as collection of data fields. These data fields will include information about the cell and will be defined later.\
\
\\begin\{figure\}[t]\
\\centering\
\\includegraphics[scale=0.5]\{pictures/cellTowersThreeSectors.png\}\
\\caption\{Cells as a system of hexagons \\cite\{frenkiel1979cellular\}\}\
\\label\{cell_network\}\
\\end\{figure\}\
\
\\subsection\{Measurement\}\
A \\textit\{measurement\} represents a smart phones registration of data about the cell it is currently connected to. This data is obtained with the help of smart phone applications and crowdsourcing. In addition to data about the cell the measurement will also include the phones current coordinates. The data fields of a measurement will be defined later. In this thesis we will say that measurements within the same cell belongs to that cell.\
\
\\section\{Thesis structure and outline\}\
\
\\newpage\
\\chapter\{Related work\}\
\\textit\{Satser paa aa bli ferdig med dette rundt 10. mai.\}\
\\section\{2010: First large scale study\}\
\\textit\{Her vil jeg beskrive den ene artikkelen jeg fant. Jeg har ikke funnet flere artikler som tar for seg dette\}\
\
\\section\{Positioning through Cell ID\}\
\
\\newpage\
\\chapter\{Developing the process\}\
\
\\textit\{Her maa jeg gaa gjennom det jeg har skrevet og strukturere seksjoner bedre. Jeg tenker at jeg maa gaa mer i dybden (forklare ting bedre) og finne bedre navn til noen av variablene som forblir gjennom hele prosessen.\}\
\
\\section\{Generating test data\}\
When developing the process for positioning cell towers, we need to be able to generate theoretical test data to test on. When developing the algorithms we want to implement and test it every step of the way to make sure it behaves as desired and required. \
\
It is widely known in the software development community that continious testing is more time efficient than only testing when the piece of software is finished. Seldom testing tends to discover flaws that runs deep into the program and takes a long time to fix. Continious testing helps us to discover flaws early, thus preventing those complex flaws.\
\
We can apply this concept to our algorithms. We are developing a process or chain of algorithms where each is dependent of the ones that come before. That is why we want to make sure each algorithm works as desired before starting on the next. Generated theoretical test data will help us see how the algorithms work. Since we are generating it ourselves we can decide its characteristics to simulate different scenarios to see how they affect the algorithms. This also lets us calculate the theoretical result in advance to compare with what the algorithms actually computes.\
\
Our test data needs to represent cells and measurements. When we generate a cell and its measurements we include the position of the cell tower. This is the most optimal value our algorithms can compute. Real data would not be able to provide the exact position, with some exceptions, but it is important that we generate complete cells so we can compare results from our algorithms to the optimal values. \
\
We use a Cartesian coordinate system for positioning. Measurements and cell towers will then be given positions in the form of x and y coordinates. A Cartesian coordinate system will almost perfectly simulate the real world. To simulate it perfectly would require an environment that matches the earths circular shape. We choose to use a Cartesian environment for simplicity because the cell sectors are too small for the earth's shape to make a significant difference.\
\
We also need to set a maximum distance from the cell tower the measurements are allowed to be positioned. In the real world, cells have different distance capabilities and cell phones have different reception capabilities. In addition to this the measurements collected for different cells can appear in a lot of different styles. Sometimes the measurements are really close to the cell tower and sometimes they are really far away from the cell tower. This makes the theoretical maximum distance difficult to set. We will just have to pick a distance that looks ok.\
\
The actual generation of test data happens as follows. The cell is generated including cell tower position and sector boundries. We then generate measurements with random positions within the cell sector.\
\
\\section\{Positioning Cell Towers Theoretically\}\
To predict the positon of a cell tower as effective as possible in real time, we need to develop heuristic algorithms that works on a random subset of the measurements available $M$. For some cells, not many measurements exist and we may have to use all of them. To predict the positon of the cell tower we start by computing a linear vector $\\vec\{v\}_\{direction\}$ from the measurements in $M$. This will give us a good impression of which direction the cell tower is pointing, but only works well on small sector angles. This is done with the Longest Vector method. After the computation of $\\vec\{v\}_\{direction\}$ we propose two possible cell tower positions, one for each endpoint of $\\vec\{v\}_\{direction\}$. The criteria for a valid cell is that every $m \\in M$ fits inside it. We use the Find Sector method for this. \
\
\\newpage\
\\section\{Longest Vector\}\
\
\\begin\{figure\}[h!]\
\\label\{fig:10deg20m\}\
\\centering\
\\begin\{subfigure\}[t]\{0.45\\textwidth\}\
    \\centering\
    \\includegraphics[scale=1]\{pictures/cell.png\}\
    \\caption\{No computations\}\
  \\end\{subfigure\}\
  \\hspace\{.03\\textwidth\}\
  \\begin\{subfigure\}[t]\{0.45\\textwidth\}\
    \\centering\
    \\includegraphics[scale=1]\{pictures/cell_lv.png\}\
    \\caption\{$\\vec\{v\}_\{direction\}$ computed with $n=10$\}\
  \\end\{subfigure\}\
\\caption\{A cell with a 10 degree sector angle and 20 measurements\}\
\\end\{figure\}\
\
\
The purpose of this algorithm is to find two measurements that are far apart from each other by looking at $n^2$ randomly picked pairs of measurements. We choose the two measurements that are furthest apart from each other to be the endpoints of $\\vec\{v\}_\{direction\}$. See figure 2.\
\
Longest Vector takes as input $M$ and $n$. First it declares the variables $ep_1$, $ep_2$ and $d_\{difference\}$ for storing the two measurements with the current largest distance between them, and that distance. For each of the following $n$ iterations it randomly picks a measurement from $M$, compares the distance between it to $n$ other randomly picked measurements from $M$, and stores the largest distance and the pair of measurements representing it in $ep_1$, $ep_2$ and $d_\{difference\}$. The algorithm outputs the vector $\\vec\{v\}_\{direction\}$ with $ep_1$ and $ep_2$ as endpoints.\
\
\\bigskip\
%\\begin\{figure\}[h!]\
\\begin\{algorithm\}[h!]\
\\label\{alg:Longest Vector\}\
  \\center\
  \\begin\{tabular\}\{|l|\}\
    \\hline\
    \\textbf\{Algorithm 1:\} Longest Vector\\\\\
    \\hline \\hline\
    \\begin\{minipage\}\{1.0\\linewidth\}\
      \\begin\{tabbing\}\
        \\=\\textbf\{output:\} \\=\\kill\
        \\>\\textbf\{input:\}\\>$M$ and $n$ \\\\ \
        \\>\\textbf\{output:\}\\>$\\vec\{v\}_\{direction\}$\
      \\end\{tabbing\}\
    \\end\{minipage\}\\\\\\hline \\hline\
    \\begin\{minipage\}\{1.0\\linewidth\}\
      \\vspace\{2pt\}\
      \\begin\{tabbing\}\
      Declare variables $ep_1$,$ep_2$ and $d_\{difference\}$\\\\\
      \\textbf\{for\} $0$ to $n$\\\\\
      %\\=\\textbf\{output:\} \\=\\kill\
      \\hspace\{10pt\}randomly pick a measurement $a \\in M$\\\\ \
      \\hspace\{10pt\}\\textbf\{for\} $0$ to $n$\\\\\
      \\hspace\{20pt\}randomly pick a measurement $b \\in M$ such that $a \\neq b$\\\\ \
      \\hspace\{20pt\}\\textbf\{if\} the distance between $a$ and $b$ is larger than the distance                   currently stored\\\\\
      \\hspace\{20pt\}in $d_\{difference\}$, store $a$ in $ep_1$, $b$ in $ep_2$, and the distance between them in         $d_\{difference\}$\\\\\
      \\textbf\{return\} $\\vec\{v\}_\{direction\}$ with $ep_1$ and $ep_2$ as endpoints\
      \\end\{tabbing\}\
    \\end\{minipage\}\\\\\
    \\hline\
  \\end\{tabular\}\
%\\end\{figure\}\
\
\\end\{algorithm\}\
\
%\\begin\{algorithm\}\
%\\caption\{Longest Vector\}\
%\\label\{alg:LV\}\
%\\begin\{algorithmic\}[1]\
%\\Procedure\{LV\}\{M, n\}\\Comment\{An array $M$ and integer $n$\}\
%\\State $m1$, $m2$\
%\\State $d \\gets 0.0$\
%\\State $i \\gets n-1$\
%\\While \{$i > 0$\}\
%\\State $m1Temp \\gets M(i--)$\
%\\State $m2Temp \\gets M(i--)$\
%\\State $dTemp \\gets$ distance from $m1Temp$ to $m2Temp$\
%\\If \{$dTemp > d$\}\
%\\State $m1 \\gets m1Temp$\
%\\State $m2 \\gets m2Temp$\
%\\State $d \\gets dTemp$\
%\\EndIf\
%\\EndWhile\
%\\State \\Return $[m1,m2]$\\Comment\{A vector with $m1$ and $m2$ as endpoints\}\
%\\EndProcedure\
%\\end\{algorithmic\}\
%\\end\{algorithm\}\
\
\
\
\
\\newpage\
\\section\{Find Sector\}\
After retrieving $\\vec\{v\}_\{direction\}$ we have two suggested solutions for which direction the cell tower is pointing. It is either from $ep_1$ to $ep_2$, or from $ep_2$ to $ep_1$. We compute solution cells for both directions. To describe the process we look at the solution where the direction of the cell tower points from $ep_1$ to $ep_2$.\
\
To provide a valid solution we need to make sure every measurement $m$ $\\in$ $M$ fits inside the sector. We start by computing a heuristic sector $C_\{heuristic\}$ with the same angle as the original cell sector, with the origin at $ep_1$, such that $\\vec\{v\}_\{direction\}$ lies in the middle of the sector. That is, the distance from a point on $\\vec\{v\}_\{direction\}$ to both boundries of $C_\{heuristic\}$ is equal for every point on $\\vec\{v\}_\{direction\}$. The computation of $C_\{heuristic\}$ is done with the Compute Sector method. After this first computation of $C_\{heuristic\}$ we do several iterations. For each iteration, if every $m$ does not fit inside we move $ep_1$ backwards along $\\vec\{v\}_\{direction\}$ by a constant factor $d_\{backwards\}$, and compute $C_\{heuristic\}$ with the new origin. The iterations stop when every $m$ fits inside $C_\{heuristic\}$.\
\
\\bigskip\
\\begin\{figure\}[h!]\
  \\center\
  \\begin\{tabular\}\{|l|\}\
    \\hline\
    \\textbf\{Algorithm 3:\} Find Sector\\\\\
    \\hline \\hline\
    \\begin\{minipage\}\{1.0\\linewidth\}\
      \\begin\{tabbing\}\
        \\=\\textbf\{output:\} \\=\\kill\
        \\>\\textbf\{input:\}\\>$\\vec\{v\}_\{direction\}$, $M$, and $d_\{backwards\}$\\\\ \
        \\>\\textbf\{output:\}\\>$C_\{heuristic\}$\
      \\end\{tabbing\}\
    \\end\{minipage\}\\\\\\hline \\hline\
    \\begin\{minipage\}\{1.0\\linewidth\}\
      \\vspace\{2pt\}\
      \\begin\{tabbing\}\
      compute initial $C_\{heuristic\}$\\\\\
      \\textbf\{while\} every measurement $m$ $\\in$ $M$ does not fit inside $C_\{heuristic\}$\\\\\
      %\\=\\textbf\{output:\} \\=\\kill\
      \\hspace\{10pt\}move $ep_1$ backwards by length $d_\{backwards\}$\\\\\
      \\hspace\{10pt\}compute new $C_\{heuristic\}$ with the new origin $ep_1$\\\\\
      \\textbf\{return\} $C_\{heuristic\}$\
      \\end\{tabbing\}\
    \\end\{minipage\}\\\\\
    \\hline\
  \\end\{tabular\}\
\\end\{figure\}\
\
\\bigskip\
\\begin\{figure\}[h!]\
  \\center\
  \\begin\{tabular\}\{|l|\}\
    \\hline\
    \\textbf\{Algorithm 4:\} Compute Sector\\\\\
    \\hline \\hline\
    \\begin\{minipage\}\{1.0\\linewidth\}\
      \\begin\{tabbing\}\
        \\=\\textbf\{output:\} \\=\\kill\
        \\>\\textbf\{input:\}\\>$\\vec\{v\}_\{direction\}$ and sector angle $\\alpha$\\\\ \
        %\\> \\>in branch decomposition \\\\\
        \\>\\textbf\{output:\}\\>$C_\{heuristic\}$\
      \\end\{tabbing\}\
    \\end\{minipage\}\\\\\\hline \\hline\
    \\begin\{minipage\}\{1.0\\linewidth\}\
      \\vspace\{2pt\}\
      \\begin\{tabbing\}\
      rotate $\\vec\{v\}_\{direction\}$ around $ep_1$ in both directions, by an angle of $\\frac\{\\alpha\}\{2\}$\\\\\
      \\textbf\{return\} $C_\{heuristic\}$ with $ep_1$ as origin and the two vectors obtained\\\\ \
      \\hspace\{35pt\}from the rotations as boundries\
      \\end\{tabbing\}\
    \\end\{minipage\}\\\\\
    \\hline\
  \\end\{tabular\}\
\\end\{figure\}\
\
\\bigskip\
As described above we apply this process on both directions of $\\vec\{v\}_\{direction\}$, thereby creating two solutions for the cell. See figure 3.\
\
\\begin\{figure\}[h!]\
\\label\{fig:cell_lv_hdcs\}\
\\centering\
\\includegraphics[scale=1]\{pictures/cell_lv_hdcs.png\}\
\\caption\{The two solution sectors are shown\}\
\\end\{figure\}\
\
%\\begin\{algorithm\}\
%\\caption\{Least Square\}\
%\\label\{alg:LS\}\
%\\begin\{algorithmic\}[1]\
%\\Procedure\{LV\}\{M, n\}\\Comment\{An array $M$ and integer $n$\}\
%\\State $x_\{min\} \\gets 113.0$\
%\\State $x_\{max\} \\gets -113.0$\
%\\State $x_\{mean\}, y_\{mean\}, xy_\{mean\}, x_\{squared\\_mean\}, x_\{mean\\_squared\}, m, b \\gets 0.0$\
%\\ForAll \{$m \\in M$\}\
%\\State $x_\{mean\} \\gets x_\{mean\} + m(x)$\
%\\State $y_\{mean\} \\gets y_\{mean\} + m(y)$\
%\\State $xy_\{mean\} \\gets xy_\{mean\} + (m(x)\\times m(y))$\
%\\State $x_\{squared\\_mean\} \\gets x_\{squared\\_mean\} + m(x)^2$\
%\\If \{$m(x) > x_\{max\}$\}\
%\\State $x_\{max\} \\gets m(x)$\
%\\EndIf\
%\\If \{$m(x) < x_\{min\}$\}\
%\\State $x_\{min\} \\gets m(x)$\
%\\EndIf\
%\\EndFor\
%\\State $x_\{mean\} \\gets \\frac\{x_\{mean\}\}\{n\}$\
%\\State $y_\{mean\} \\gets \\frac\{y_\{mean\}\}\{n\}$\
%\\State $xy_\{mean\} \\gets \\frac\{xy_\{mean\}\}\{n\}$\
%\\State $x_\{squared\\_mean\} \\gets \\frac\{x_\{squared\\_mean\}\}\{n\}$\
%\\State $x_\{mean\\_squared\} \\gets (x_\{mean\})^2$\
%\\State $m \\gets \\frac\{(x_\{mean\}\\times y_\{mean\})-xy_\{mean\}\}\{x_\{mean\\_squared\}-x_\{squared\\_mean\}\}$\
%\\State $b \\gets y_\{mean\}-(m\\times x_\{mean\})$\
%\\State $ep1 \\gets (x_\{min\},b+(m\\times x_\{min\}))$\
%\\State $ep2 \\gets (x_\{max\},b+(m\\times x_\{max\}))$\
%\\State \\Return $[ep1,ep2]$\\Comment\{A vector with $ep1$ and $ep2$ as endpoints\}\
%\\EndProcedure\
%\\end\{algorithmic\}\
%\\end\{algorithm\}\
\
\\newpage\
\\section\{Greater angles\}\
This approach gets less and less reliable when we increase the sector angle $\\alpha$ of the cell. For $\\alpha = 10$, we can be quite sure that we will get usable results as long as we have a properly large set of measurements to work with. When increasing $\\alpha$ the area of the sector grows. This will increase the probability of computing a poor vector if we are unlucky with the subset of measurements used and the combination of pairs of measurements. \
\
We now present several tables where we show the error of the heuristic cells. The error is the average distance between the actuall position of the cell tower and the one of the two heurisic cell towers closest to it. We base each error on 1000 test subjects. That is, 1000 generated cells. Each error is a function of $\\alpha$, $M$ and $n$. We use $d_\{backwards\} = 10$ for these computations.\
\
\\bigskip\
\\begin\{table\}[h!]\
\\centering\
\\caption\{$M=10$\}\
\\label\{tab:10m\}\
\\begin\{tabular\}\{|c|c|c|c|c|\}\
\\hline\
$n \\backslash \\alpha$ & $10^\{\\circ\}$ & $45^\{\\circ\}$ & $90^\{\\circ\}$ & $120^\{\\circ\}$ \\\\ \\hline\
10 & 26,26 & 26,72 & 48,72 & 62,68 \\\\ \\hline\
\\end\{tabular\}\
\\end\{table\}\
\
\\bigskip\
\\begin\{table\}[h!]\
\\centering\
\\caption\{$M=100$\}\
\\label\{tab:10m\}\
\\begin\{tabular\}\{|c|c|c|c|c|\}\
\\hline\
$n \\backslash \\alpha$ & $10^\{\\circ\}$ & $45^\{\\circ\}$ & $90^\{\\circ\}$ & $120^\{\\circ\}$ \\\\ \\hline\
20 & 47,80 & 48,66 & 100,83 & 107,43 \\\\ \\hline\
40 & 48,91 & 51,48 & 109,12 & 108,98 \\\\ \\hline\
60 & 48,85 & 50,20 & 111,46 & 108,57 \\\\ \\hline\
80 & 49,82 & 49,40 & 112,58 & 108,79 \\\\ \\hline\
100 & 48,30 & 49,61 & 112,32 & 108,86 \\\\ \\hline\
\\end\{tabular\}\
\\end\{table\}\
\
\\bigskip\
\\begin\{table\}[h!]\
\\centering\
\\caption\{$M=1000$\}\
\\label\{tab:10m\}\
\\begin\{tabular\}\{|c|c|c|c|c|\}\
\\hline\
$n \\backslash \\alpha$ & $10^\{\\circ\}$ & $45^\{\\circ\}$ & $90^\{\\circ\}$ & $120^\{\\circ\}$ \\\\ \\hline\
200 & 58,30 & 59,03 & 116,76 & 116,58 \\\\ \\hline\
400 & 55,37 & 58,87 & 116,23 & 116,86 \\\\ \\hline\
600 & 57,59 & 58,79 & 116,35 & 117,17 \\\\ \\hline\
800 & 56,88 & 58,77 & 116,35 & 117,47 \\\\ \\hline\
1000 & 56,59 & 59,91 & 116,35 & 117,65 \\\\ \\hline\
\\end\{tabular\}\
\\end\{table\}\
\
\\newpage\
To put these numbers into perspective, we give an example in figure 4.\
\
\\begin\{figure\}[h!]\
\\label\{fig:cell_perspective\}\
\\centering\
\\includegraphics[scale=1]\{pictures/cell_perspective.png\}\
\\caption\{Example cell\}\
\\end\{figure\}\
\
The black cell is the generated cell $C$ and the pink and cyan colored cells are heuristic cells computed from $C$. We call the pink one $C_\{pink\}$ and the cyan one $C_\{cyan\}$. The distance from the cell tower in $C$ to the cell tower in $C_\{pink\}$ is 200,29, and so the error of $C_\{pink\}$ is 200,29. The distance from the cell tower in $C$ to the cell tower in $C_\{cyan\}$ is 55,61, and so the error of $C_\{cyan\}$ is 55,61.\
\
As we can see from the tables the error increases between $45^\{\\circ\}$ and $90^\{\\circ\}$. To understand the reason for this consider the distance $d_\{corners\}$ between two measurements that are positioned at the corners of the cell, and the distance $d_\{correct\}$ between two measurements where one is positioned close to the cell tower and the other as far away from the cell tower as possible. With a small angle $d_\{correct\}$ is larger than $d_\{corners\}$. But when the angle increases above a certain point, $d_\{corners\}$ will get larger than $d_\{correct\}$. See figure 5.\
\
\\newpage\
\\begin\{figure\}[h!]\
%\\label\{fig:10deg20m\}\
\\centering\
\\begin\{subfigure\}[t]\{0.45\\textwidth\}\
    \\centering\
    \\includegraphics[scale=1]\{pictures/cell_errorincrease_smallangle.png\}\
    \\caption\{$30^\{\\circ\}$ sector angle\}\
  \\end\{subfigure\}\
  \\hspace\{.03\\textwidth\}\
  \\begin\{subfigure\}[t]\{0.45\\textwidth\}\
    \\centering\
    \\includegraphics[scale=1]\{pictures/cell_errorincrease_largeangle.png\}\
    \\caption\{$90^\{\\circ\}$ sector angle\}\
  \\end\{subfigure\}\
\\caption\{$d_\{corners\}$ is represented by the red lines, $d_\{correct\}$ is represented by the green lines\}\
\\end\{figure\}\
\
Here we clearly see that $d_\{corners\}$ is smaller than $d_\{correct\}$ for a sector angle of $30^\{\\circ\}$, and $d_\{corners\}$ is larger than $d_\{correct\}$ for a sector angle of $90^\{\\circ\}$. For large angles and many datapoints considered, $\\vec\{v\}_\{direction\}$ will most likely be similar to $d_\{corners\}$.\
\
\\section\{Sector angle of $120^\{\\circ\}$\}\
We now turn our attention toward cells where the sector angles are $120^\{\\circ\}$. In the real world, a cell tower divides its coverage area into three different cells, each with a cell sector of $120^\{\\circ\}$. The cell tower then covers everything within its range capabilities, in an angle of $360^\{\\circ\}$. For a sector angle of $120^\{\\circ\}$, the Longest Vector method computes a poor $\\vec\{v\}_\{direction\}$, as explained above. And as we have seen, the resulting heuristic cells have a large error. See figure 6. \
\
\\begin\{figure\}[h!]\
\\label\{fig:cell_120_hdcs\}\
\\centering\
\\includegraphics[scale=0.6]\{pictures/cell_120_hdcs.png\}\
\\caption\{Cell sector of $120^\{\\circ\}$\}\
\\end\{figure\}\
\
From now on we will focus on cells with sector angles of $120^\{\\circ\}$.\
\
\\newpage\
\\section\{Received Signal strength\}\
We now introduce the parameter received signal strength (RSS) for a measurement. If the measurement is close to the cell tower the RSS is strong, and if it is far from the cell tower the RSS is weak. To make the RSS as realistic as possible it is stored as a negative value since the RSS in the real world is a negative Decibel-milliwatts (dBm) number. For our theoretical purposes, the RSS is calculated by multiplying the distance from the measurement to the cell tower by -1. This means a measurements RRS is strong if it is close to 0, and week if it is far from it.\
\
We now have a much stronger variable to base our computations on. To incorporate it, we change the \\textbf\{if\} statement in the Longest Vector method to the following.\
\
\
\\begin\{figure\}[h!]\
  \\center\
  \\begin\{tabular\}\{|l|\}\
    \\hline\
    \\begin\{minipage\}\{1.0\\linewidth\}\
      \\vspace\{2pt\}\
      \\textbf\{if\} the difference in RSS between $a$ and $b$ is larger than the difference in RSS currently stored in $d_\{difference\}$, store $a$ in $ep_1$, $b$ in $ep_2$, and the difference in RSS between them in $d_\{difference\}$\
      \\vspace\{2pt\}\
    \\end\{minipage\}\\\\\
    \\hline\
  \\end\{tabular\}\
\\end\{figure\}\
\
We now compute new error values using RSS. We still use $d_\{backwards\}=10$.\
\
\\begin\{figure\}[h!]\
%\\label\{fig:10deg20m\}\
\\centering\
\\begin\{subfigure\}[t]\{0.30\\textwidth\}\
    \\centering\
    \\caption\{$\\alpha=120$, $M=10$\}\
    \\begin\{tabular\}\{|c|c|\}\
\\hline\
$n=10$ & 30,79\\\\ \\hline\
\\end\{tabular\}\
  \\end\{subfigure\}\
  %\\hspace\{.03\\textwidth\}\
  \\begin\{subfigure\}[t]\{0.30\\textwidth\}\
    \\centering\
    \\caption\{$\\alpha=120$, $M=100$\}\
    \\begin\{tabular\}\{|c|c|\}\
\\hline\
$n=10$ & 55,10 \\\\ \\hline\
$n=20$ & 53,66 \\\\ \\hline\
$n=40$ & 54,77 \\\\ \\hline\
$n=80$ & 52,77 \\\\ \\hline\
\\end\{tabular\}\
    \
  \\end\{subfigure\}\
  %\\hspace\{.03\\textwidth\}\
  \\begin\{subfigure\}[t]\{0.30\\textwidth\}\
    \\centering\
    \\caption\{$\\alpha=120$, $M=1000$\}\
    \\begin\{tabular\}\{|c|c|\}\
\\hline\
$n=30$ & 62,60 \\\\ \\hline\
$n=50$ & 61,94 \\\\ \\hline\
$n=100$ & 62,71 \\\\ \\hline\
$n=200$ & 61,35 \\\\ \\hline\
$n=400$ & 62,97 \\\\ \\hline\
$n=800$& 63,69 \\\\ \\hline\
\\end\{tabular\}\
  \\end\{subfigure\}\
%\\caption\{$d_\{corners\}$ is represented by the red lines, $d_\{correct\}$ is represented by the green lines\}\
\\end\{figure\}\
\
As we can see, the error values are significantly reduced. With RSS $\\vec\{v\}_\{direction\}$ is similar to $d_\{correct\}$ in figure 5a, only it works for angles where $d_\{corners\}$ is larger than $d_\{correct\}$, which was a problem when we based $\\vec\{v\}_\{direction\}$ on the distance between to measurements.\
\
\\section\{Optimalization of $d_\{backwards\}$\}\
We need to consider the variable $d_\{backwards\}$ when making these computations. Recall that $d_\{backwards\}$ is the constant that decides how far $ep_1$ will be moved backwards for each iteration in the Find Sector method. If we use a small $d_\{backwards\}$, Find Sector will need more iterations to find a cell where every measurement fit than if we use a large $d_\{backwards\}$, and thus take longer time to complete. On the other hand, using a small $d_\{backwards\}$ gives more accurate results.\
\
We must also take into consideration the time it takes to compute a solution cell. This process should be able to give results in real time, so we do not have unlimited time. For a computation with $\\alpha = 120$, $M=1000$, $n=800$ and $d=1$, the average time it takes to compute a solution cell is 0,01 seconds. This means we are within our time constraints with a good margin, so we will not include it in our tables yet.\
\
In the following tables we show errors as a function of $M$, $n$ and $d_\{backwards\}$. Remember that $\\alpha = 120$.\
\
\\bigskip\
\\begin\{table\}[h!]\
\\centering\
\\caption\{$\\alpha = 120$, $M=10$\}\
%\\label\{tab:10m\}\
\\begin\{tabular\}\{|c|c|c|c|c|c|c|c|\}\
\\hline\
$n \\backslash d_\{backwards\}$ & 1 & 2 & 4 & 8 & 16 & 32 & 64 \\\\ \\hline\
10 & 26,81 & 29,71 & 28,99 & 31,04 & 32,75 & 41,79 & 61,78 \\\\ \\hline\
\\end\{tabular\}\
\\end\{table\}\
\
\\bigskip\
\\begin\{table\}[h!]\
\\centering\
\\caption\{$\\alpha = 120$, $M=100$\}\
%\\label\{tab:10m\}\
\\begin\{tabular\}\{|c|c|c|c|c|c|c|c|\}\
\\hline\
$n \\backslash d_\{backwards\}$ & 1 & 2 & 4 & 8 & 16 & 32 & 64 \\\\ \\hline\
10 & 49,09 & 51,20 & 51,68 & 53,48 & 59,22 & 66,01 & 85,17 \\\\ \\hline\
20 & 48,58 & 49,02 & 51,10 & 53,73 & 57,23 & 65,88 & 84,31 \\\\ \\hline\
40 & 50,50 & 50,30 & 51,91 & 53,46 & 56,63 & 65,62 & 86,48 \\\\ \\hline\
80 & 49,28 & 49,38 & 51,67 & 52,62 & 60,17 & 66,28 & 87,20 \\\\ \\hline\
\\end\{tabular\}\
\\end\{table\}\
\
\\bigskip\
\\begin\{table\}[h!]\
\\centering\
\\caption\{$\\alpha = 120$, $M=1000$\}\
%\\label\{tab:10m\}\
\\begin\{tabular\}\{|c|c|c|c|c|c|c|c|\}\
\\hline\
$n \\backslash d_\{backwards\}$ & 1 & 2 & 4 & 8 & 16 & 32 & 64 \\\\ \\hline\
30 & 57,48 & 60,24 & 61,04 & 61,89 & 66,11 & 74,96 & 93,34 \\\\ \\hline\
50 & 57,72 & 58,85 & 61,10 & 61,87 & 66,64 & 73,86 & 93,68 \\\\ \\hline\
100 & 56,78 & 59,90 & 59,73 & 62,39 & 67,42 & 76,41 & 94,47 \\\\ \\hline\
200 & 58,86 & 59,38 & 59,91 & 62,12 & 64,70 & 73,83 & 94,93 \\\\ \\hline\
400 & 58,51 & 57,45 & 60,93 & 63,18 & 64,92 & 75,38 & 92,34 \\\\ \\hline\
800 & 56,43 & 57,22 & 60,63 & 62,10 & 66,41 & 75,69 & 92,99 \\\\ \\hline\
\\end\{tabular\}\
\\end\{table\}\
\
\\newpage\
\\section\{Deadzones\}\
To properly simulate a cell we need to consider that there may be areas within the cell sector where there are no measurements, so called deadzones. Examples are tall buildings that completely blocks the signal, or lakes. Do our procedure work even though small or large deadzones exist? What makes this difficult to simulate is the variation in size, shape and location of potential deadzones. Practically it is not possible to test for different shapes, so we keep this variable constant.\
\
\\begin\{figure\}[h!]\
%\\label\{fig:10deg20m\}\
\\centering\
\\begin\{subfigure\}[t]\{0.45\\textwidth\}\
    \\centering\
    \\includegraphics[scale=0.7]\{pictures/cell_dz1.png\}\
    \\caption\{$r_\{dz\}=30$\}\
  \\end\{subfigure\}\
  \\hspace\{.03\\textwidth\}\
  \\begin\{subfigure\}[t]\{0.45\\textwidth\}\
    \\centering\
    \\includegraphics[scale=0.7]\{pictures/cell_dz2.png\}\
    \\caption\{$r_\{dz\}=40$\}\
  \\end\{subfigure\}\
\\caption\{2 cells, each with a deaszone\}\
\\end\{figure\}\
\
To create a deadzone we take a random point within the cell sector and a radius $r_\{dz\}$. Every measurement within the circle this point and radius forms are removed. This strategy also stimulates the fact that for example only 40\\% of a lake may be within the sell sector.\
\
In the following tables we show errors as a function of $M$, $n$ and $r_\{dz\}$. $\\alpha=120$ and $d_\{backwards\}=1$ for every computation.\
\
\\bigskip\
\\begin\{table\}[h!]\
\\centering\
\\caption\{$\\alpha = 120$, $d_\{backwards\}=1$, $M=100$\}\
%\\label\{tab:10m\}\
\\begin\{tabular\}\{|c|c|c|c|c|c|\}\
\\hline\
$n \\backslash r_\{dz\}$ & 20 & 30 & 40 & 50 & 60 \\\\ \\hline\
10 & 51,00 & 51,07 & 54,55 & 55,22 & 53,02 \\\\ \\hline\
20 & 49,27 & 51,30 & 52,29 & 54,50 & 54,92 \\\\ \\hline\
40 & 49,95 & 50,32 & 54,35 & 54,07 & 55,53 \\\\ \\hline\
80 & 50,15 & 51,29 & 51,47 & 53,49 & 54,07 \\\\ \\hline\
\\end\{tabular\}\
\\end\{table\}\
\
\\bigskip\
\\begin\{table\}[h!]\
\\centering\
\\caption\{$\\alpha = 120$, $d_\{backwards\}=1$ $M=1000$\}\
%\\label\{tab:10m\}\
\\begin\{tabular\}\{|c|c|c|c|c|c|\}\
\\hline\
$n \\backslash r_\{cz\}$ & 20 & 30 & 40 & 50 & 60 \\\\ \\hline\
30 & 59,84 & 61,13 & 61,74 & 61,37 & 62,52 \\\\ \\hline\
50 & 59,11 & 59,48 & 61,44 & 62,30 & 63,12 \\\\ \\hline\
100 & 60,52 & 58,56 & 59,00 & 63,19 & 62,49 \\\\ \\hline\
200 & 58,62 & 59,65 & 60,92 & 60,63 & 61,98 \\\\ \\hline\
400 & 58,50 & 59,43 & 60,72 & 62,53 & 62,80 \\\\ \\hline\
800 & 60,65 & 60,84 & 60,90 & 59,68 & 63,02 \\\\ \\hline\
\\end\{tabular\}\
\\end\{table\}\
\
\\newpage\
\\section\{Chose a heuristic cell\}\
We have now come to the point where we have to pick one of the two heuristic cells we have proposed. We look at the case where the measurements are equipped with RSS and the case where they are not, though the methods are very similar. \
\
We first look at the case where the measurements are not equipped with RSS. In a cell sector, the further away from the cell tower we get, the distance between the two vectors forming the edges of the cell sector, $v_1$ and $v_2$, increases. The perfect vector $v$ to give an impression of which direction the cell tower is pointing would intersect with the cell tower and go between $v_1$ and $v_2$ such that the distance from $v$ to $v_1$ and the distance from $v$ to $v_2$ always are equal. This means that measurements further away from the cell tower may be further away from $v$, than those close to it. Now consider the two endpoints of $v$, $ep_1$ and $ep_2$, and our randomly distributed measurements. Let $ep_1$ be the endpoint on top of the cell tower, $m_1$ be those measurements closer to $ep_1$ than $ep_2$, and $m_2$ be those measurements closer to $ep_2$ than $ep_1$. The mean of the least possible distances from the points in $m_1$ to $v$ are very likely to be smaller than the mean of the least possible distances from the points in $m_2$ to $v$, which means we can presume that $ep_1$ is the endpoint of $v$ that is on top of the cell tower.\
\
We do not have such a perfect direction vector $v$, but we use $\\vec\{v\}_\{direction\}$ instead. This will not provide us with the exact location of the cell tower, but some point relatively close to it, depending on the sector angle. When we have calculated which endpoint of $\\vec\{v\}_\{direction\}$ that is most likely to be closest to the cell tower we simply pick the heuristic cell whos cell tower position is closest to this endpoint.\
\
Algorithm 5 takes as input $M$, $\\vec\{v\}_\{direction\}$, the two precomputed heuristic cells $C_\{heuristic1\}$ and $C_\{heuristic2\}$, and $n$. We start by iterating over $n$ random measurements $S \\in M$. We divide $S$ into two subsets; the measurements that are closer to the first endpoint $ep_1$ than the second endpoint $ep_2$ of $\\vec\{v\}_\{direction\}$, and the measurements that are closer to $ep_2$ than $ep_1$. We then calculate the average least possible distance from the measurements in the two subsets of $S$ to $\\vec\{v\}_\{direction\}$, respectively. For the subset of $S$ with the smallest average distance we pick the heuristic cell whos cell towers position is closest to the related endpoint of $\\vec\{v\}_\{direction\}$.\
\
\\newpage\
\\begin\{figure\}[h!]\
  \\center\
  \\begin\{tabular\}\{|l|\}\
    \\hline\
    \\textbf\{Algorithm 5:\} Choose heuristic cell when RSS is not present\\\\\
    \\hline \\hline\
    \\begin\{minipage\}\{1.0\\linewidth\}\
      \\begin\{tabbing\}\
        \\=\\textbf\{output:\} \\=\\kill\
        \\>\\textbf\{input:\}\\>$M$, $n$, $\\vec\{v\}_\{direction\}$, $C_\{heuristic1\}$ and $C_\{heuristic2\}$\\\\ \
        \\>\\textbf\{output:\}\\>$C_\{heuristic1\}$ or $C_\{heuristic2\}$\
      \\end\{tabbing\}\
    \\end\{minipage\}\\\\\\hline \\hline\
    \\begin\{minipage\}\{1.0\\linewidth\}\
      \\vspace\{2pt\}\
      \\begin\{tabbing\}\
      pick $n$ random measurements $S \\in M$\\\\\
      \\textbf\{for\} all measurements $\\in S$, calculate the average least possible distance from\\\\\
      \\hspace\{18pt\}the measurements that are closer to $ep_1$ than $ep_2$, to $\\vec\{v\}_\{direction\}$, and the \\\\\
      \\hspace\{18pt\}average least possible distance from the measurements that are closer to\\\\\
      \\hspace\{18pt\}$ep_2$ than $ep_1$, to $\\vec\{v\}_\{direction\}$\\\\\
      %\\=\\textbf\{output:\} \\=\\kill\
      \\textbf\{if\} the subset $\\in S$ related to $ep_1$ has a smaller average least possible distance\\\\\
      \\hspace\{12pt\}to $\\vec\{v\}_\{direction\}$ than the subset $\\in S$ related to $ep_2$, return $C_\{heuristic1\}$ if its\\\\\
      \\hspace\{12pt\}cell tower position is closer to $ep_1$ than the cell tower position of $C_\{heuristic2\}$\\\\\
      \\hspace\{12pt\}or return $C_\{heuristic2\}$ if its cell tower position is closer to $ep_1$ than the cell\\\\\
      \\hspace\{12pt\}tower position of $C_\{heuristic1\}$\\\\\
      \\textbf\{if\} the subset $\\in S$ related to $ep_2$ has a smaller average least possible distance\\\\\
      \\hspace\{12pt\}to $\\vec\{v\}_\{direction\}$ than the subset $\\in S$ related to $ep_1$, return $C_\{heuristic1\}$ if its\\\\\
      \\hspace\{12pt\}cell tower position is closer to $ep_2$ than the cell tower position of $C_\{heuristic2\}$\\\\\
      \\hspace\{12pt\}or return $C_\{heuristic2\}$ if its cell tower position is closer to $ep_2$ than the cell\\\\\
      \\hspace\{12pt\}tower position of $C_\{heuristic1\}$\
      \\end\{tabbing\}\
    \\end\{minipage\}\\\\\
    \\hline\
  \\end\{tabular\}\
\\end\{figure\}\
\
As discussed earlier in section 6.3 and 6.4, when the measurements are not equipped with RSS and we compute $\\vec\{v\}_\{direction\}$ based on distance between the measurements, we may end up with a very poor $\\vec\{v\}_\{direction\}$, and hence very poor heuristic cells. There are two paremeters that decide if $\\vec\{v\}_\{direction\}$ will look more like $d_\{corners\}$ or look more like $d_\{correct\}$. The first one, which we have discussed earlier, is the angle of the sector. If the angle is small $\\vec\{v\}_\{direction\}$ will more likely look like $d_\{correct\}$, and if it is large it will more likely look like $d_\{corners\}$.\
\
The second parameter is the distance between the measurement closest to the cell tower and the one furthest away. If this distance is larger than the largest distance across the cell between two other measurements, we may still get a good $\\vec\{v\}_\{direction\}$, even when our sector angle is $120^\{\\circ\}$. Of course, if there are few of these measurements that provide such a distance, to choose from, we need to be lucky with the random pairing of measurements in the Longest Vector algorithm.\
\
For cells where the measurements are equiped with RSS, we use the same concept as for when the measurements are not equipped with RSS. We take advantage of the fact that measurements closer to the cell tower most likely have a stronger RSS than those further away from it. Instead of using the mean of the least possible distances we use the mean of the RSS for the points in $m_1$ and $m_2$. If the mean of the RSS for $m_1$ is higher than the mean of the RSS for $m_2$, then $ep_1$ is on top of the cell tower. We again use $\\vec\{v\}_\{direction\}$ and pick the heuristic cell whos cell tower position is closest to the endpoint closest to the cell tower.\
\
\\begin\{figure\}[h!]\
  \\center\
  \\begin\{tabular\}\{|l|\}\
    \\hline\
    \\textbf\{Algorithm 6:\} Choose heuristic cell when RSS is present\\\\\
    \\hline \\hline\
    \\begin\{minipage\}\{1.0\\linewidth\}\
      \\begin\{tabbing\}\
        \\=\\textbf\{output:\} \\=\\kill\
        \\>\\textbf\{input:\}\\>$M$, $n$, $\\vec\{v\}_\{direction\}$, $C_\{heuristic1\}$ and $C_\{heuristic2\}$\\\\ \
        \\>\\textbf\{output:\}\\>$C_\{heuristic1\}$ or $C_\{heuristic2\}$\
      \\end\{tabbing\}\
    \\end\{minipage\}\\\\\\hline \\hline\
    \\begin\{minipage\}\{1.0\\linewidth\}\
      \\vspace\{2pt\}\
      \\begin\{tabbing\}\
      pick $n$ random measurements $S \\in M$\\\\\
      \\textbf\{for\} all measurements $\\in S$, calculate the average RSS for the measurements\\\\\
      \\hspace\{18pt\}that are closer to $ep_1$ than $ep_2$, and the average RSS for the measurements\\\\\
      \\hspace\{18pt\}that are closer to $ep_2$ than $ep_1$\\\\\
      %\\=\\textbf\{output:\} \\=\\kill\
      \\textbf\{if\} the subset $\\in S$ related to $ep_1$ has a higher average RSS than the subset $\\in S$\\\\\
      \\hspace\{12pt\}related to $ep_2$, return $C_\{heuristic1\}$ if its cell tower position is closer to $ep_1$\\\\\
      \\hspace\{12pt\}than the cell tower position of $C_\{heuristic2\}$ or return $C_\{heuristic2\}$ if its cell\\\\\
      \\hspace\{12pt\}tower position is closer to $ep_1$ than the cell tower position of $C_\{heuristic1\}$\\\\\
      \\textbf\{if\} the subset $\\in S$ related to $ep_2$ has a higher average RSS than the subset $\\in S$\\\\\
      \\hspace\{12pt\}related to $ep_1$, return $C_\{heuristic1\}$ if its cell tower position is closer to $ep_2$\\\\\
      \\hspace\{12pt\}than the cell tower position of $C_\{heuristic2\}$ or return $C_\{heuristic2\}$ if its cell\\\\\
      \\hspace\{12pt\}tower position is closer to $ep_2$ than the cell tower position of $C_\{heuristic1\}$\
      \\end\{tabbing\}\
    \\end\{minipage\}\\\\\
    \\hline\
  \\end\{tabular\}\
\\end\{figure\}\
\
\\newpage\
\\section\{Several cells\}\
\\textit\{Basert paa informasjon jeg har funnet om cell id er det mulig aa si hvilke celler som sammen dekker et 360 graders omraade. Hvis man har disse tre cellene som dekker 120 grader hver vil jeg bruke dette til aa finne posisjonen til cell tower. Jeg mistenker at dette kan bli tidkrevende, saa jeg er usikker paa hvor grundig jeg faar gjort dette.\}\
\
\\newpage\
\\chapter\{Experimenting on real data\}\
We will now experiment on real data obtained from OpenCellID. The first step is getting access to it. We explain two different approaches. The second step is handling the large amounts of data. We will discuss the format and structure of it, and how to select subsets to test on. To completely understand the results it is important to have a visual representation of the outcomes. OpenCellID use Leaflet, which is an open-source JavaScript library for interactive maps. In order to compare our visual results directly with OpenCellID's visual service, we implement a simple version of Leaflet.\
\\section\{Accessing the data\}\
First, we need an API-key. This key needs to be included every time we want access to data on OpenCellID.org. Obtaining the key is very simple. We only need to register on the site with our name and email.\
\
When we have the API-key there are two ways to access the data. The first way is to download a copy of the entire database to a computer. The only restriction on this approach is a specific number of times a day we are allowed to download different parts of the database for free. The number of times vary for the different datasets, but the ones we are allowed to download most for free, we can download three times a day. If we need more downloads a day, we have to pay for it.\
\
The second approach is doing HTTP GET or POST requests to OpenCellID's servers. This approach lets us ask for very specific parts of the data by adding parameters to the request. Those contributing to OpenCellID can do this as much as they want. Others need to pay for it.\
\
We take advantage of both approached. The first approach is handy when we want to compute statistics and get an overview of the data. For example finding out how many cells have been registered in Norway, or how many cells there exists of the network type GSM. The second approach is more useful when we want to target small subsets of data because then we do not whish to traverse through the entire database every time. We use this approach when testing our process.\
\
\\section\{Coping with the data\}\
\\subsection\{The data objects\}\
The data provided at OpenCellID is structured as follows. There are cells and measurements objects. The data fields for a measurement contains information the smart phone applications registers. The data fields for a cell contains information based on it's measurements data fields.\
\
Table \\ref\{table:cell\} and \\ref\{table:measurement\} describes the data fields of cells and measurements, respectively.\
\
%urelevante felter\
\
\\begin\{table\}[h!]\
  \\center\
  \\begin\{tabularx\}\{\\textwidth\}\{|l|X|\}\
    \\hline\
    \\cellcolor[gray]\{0.9\}Data field&\\cellcolor[gray]\{0.9\}Description\\\\\\hline\
    radio & Network type. Either GSM, UMTS, LTE or CDMA. \\\\\\hline\
    mcc & Mobile Country Code. \\\\\\hline\
    net & Mobile Network code (MNC) for GSM, UMTS and LTE.\\newline System IDentification number (SID) for CDMA. \\\\\\hline\
    area & Location Area Code (LAC) for GSM and UMTS.\\newline Tracking Area Code (TAC) for LTE.\\newline Network IDentification number (NID) for CDMA. \\\\\\hline\
    cell & Cell ID (CID) for GSM and LTE.\\newline UTRAN Cell ID/LCID for UMTS.\\newline Base station IDentifier number (BID) for CDMA. \\\\\\hline\
    unit & Primary Scrambling Code (PSC) for UMTS.\\newline Physichal Cell ID (PCI) for LTE.\\newline Empty for GSM and CDMA. \\\\\\hline\
    lon & Longitude in degrees between -180.0 and 180.0. \\\\\\hline\
    lat & Latitude in degrees between -90.0 and 90.0. \\\\\\hline\
    range & Estimated cell range, in meters. \\\\\\hline\
    samples & Total number of the cell's measurements. \\\\\\hline\
    changeable & If 1: The lon,lat values has been calculated from available measurements.\\newline If 0: The lon,lat values are exact - no measurements have been used to calculate it. \\\\\\hline\
    created & The first time the cell was seen and added to the database. \\\\\\hline\
    updated & The last time the cell was seen, and thus updated. \\\\\\hline\
    averageSignal & Average signal strength from all the cell's measurements. \\\\\\hline\
  \\end\{tabularx\}\
  \\caption\{OpenCellID Cell object\}\
  \\label\{table:cell\}\
\\end\{table\}\
\
\\begin\{table\}[h!]\
  \\center\
  \\begin\{tabularx\}\{\\textwidth\}\{|l|X|\}\
    \\hline\
    \\cellcolor[gray]\{0.9\}Data field&\\cellcolor[gray]\{0.9\}Description\\\\\\hline\
    mcc & Mobile Country Code. \\\\\\hline\
    net & Mobile Network code (MNC) for GSM, UMTS and LTE.\\newline System IDentification number (SID) for CDMA. \\\\\\hline\
    area & Location Area Code (LAC) for GSM and UMTS.\\newline Tracking Area Code (TAC) for LTE.\\newline Network IDentification number (NID) for CDMA. \\\\\\hline\
    cell & Cell ID (CID) for GSM and LTE.\\newline UTRAN Cell ID/LCID for UMTS.\\newline Base station IDentifier number (BID) for CDMA. \\\\\\hline\
    lon & Longitude in degrees between -180.0 and 180.0. \\\\\\hline\
    lat & Latitude in degrees between -90.0 and 90.0. \\\\\\hline\
    signal & Signal level in dBm or as defined in \\cite[section 8.5]\{TS127007\}. \\\\\\hline\
    measured & When the measurement was measured. \\\\\\hline\
    created & When the measurement was added to the database. \\\\\\hline\
    rating & GPS quality/accuracy information in metres. \\\\\\hline\
    speed & Speed of the phone when the measurement was measured. \\\\\\hline\
    direction & Heading direction of the phone when the measurement was measured. \\\\\\hline\
    radio & Network type. Either GSM, UMTS, LTE or CDMA. \\\\\\hline\
    ta & Timing advance; only for GSM and LTE. \\\\\\hline\
    rnc & Radio Network Controller; only for UMTS. \\\\\\hline\
    cid & Cell ID (short); only for UMTS. \\\\\\hline\
    psc & Primary Scrambling Code; only for UMTS. \\\\\\hline\
    tac & Tracking Area Code; only for LTE. \\\\\\hline\
    pci & Physical Cell ID; only for LTE. \\\\\\hline\
    sid & System Identifier; only for CDMA. \\\\\\hline\
    nid & Network Identifier; only for CDMA. \\\\\\hline\
    bid & Base station ID; only for CDMA. \\\\\\hline\
  \\end\{tabularx\}\
  \\caption\{OpenCellID Measurement object\}\
  \\label\{table:measurement\}\
\\end\{table\}\
\
\\subsection\{Getting an overview\}\
As we can see in table \\ref\{table:cell\} and \\ref\{table:measurement\} there are several data fields, but some of them are irrelevant to us. For both cells and measurements we need four different values to identify a cell; mcc, net, area and cell. These tells us which country, which network, the area within that country and which ID belongs to the cell, respectively. We also need to know the longitude and latitude of the cells and measurements, and the samples field in the cell object will come in handy when we want to compare our process on few and many measurements.\
\
As mentioned earlier every cell position is calculated from the cell's measurements. But there are some exceptions. The changeble datafield tells us whether the cell position has been calculated using available measurements or not. If the changeable value is 0 the position is exact. OpenCellID has gotten access to data about exact cell tower positions from certain cellular network operators in certain countries. The countries this concerns is Russia, Germany and Poland. We learned this by writing a small piece of code that traverses through the dataset containing the cells and registers the mcc values of the rows where the changeable value is 0. To know that certain cells contain the exact location of the cell tower will be very valuable to us when testing our process. This lets us compare our results to the exact values so we can know to which degree our process works.\
\
When testing our process we need to choose a subset from the database to test it on. Considering the radio data field is a good first step. This field tells us if the cell uses either the GSM, UMTS, LTE or CDMA technology to broadcast it's signal. Table \\ref\{table:radio_distribution\} shows how the entire dataset of available cells is distributed with regard to the radio data field. We learned these numbers by writing a piece of code that counts all the cells using GSM technology, counts all the cells using UMTS technology, and so on.\
\
\\begin\{table\}[h!]\
  \\center\
  \\begin\{tabular\}\{|l|l|\}\
    \\hline\
    \\cellcolor[gray]\{0.9\}radio&\\cellcolor[gray]\{0.9\}Number of cells\\\\\\hline\
    GSM & 4,098,870 \\\\\\hline\
    UMTS & 3,342,507 \\\\\\hline\
    LTE & 32,782 \\\\\\hline\
    CDMA & 30,016 \\\\\\hline \\hline\
    \\textbf\{Total\} & \\textbf\{7,504,176\} \\\\\\hline\
  \\end\{tabular\}\
  \\caption\{Distribution of cells over broadcasting technology\}\
  \\label\{table:radio_distribution\}\
\\end\{table\}\
\
As we can see from table \\ref\{table:radio_distribution\}, the OpenCellID database contains most cells that uses GSM technology. Since we have no deep knowledge about the data, we conclude that this type of cell is the most favorable type to do experiments on. We are also interested in the cells where the data field changeable has the value 0. Table \\ref\{table:exact_GSM_distribution\} shows how the GSM cells, where the changeable value is 0, is distributed over the countries Russia, Germany and Poland. We learned these numbers by writing a piece of code that counts the cells in question for each of the three countries.\
\
\\begin\{table\}[h!]\
  \\center\
  \\begin\{tabular\}\{|l|l|\}\
    \\hline\
    \\cellcolor[gray]\{0.9\}Country&\\cellcolor[gray]\{0.9\}Number of cells\\\\\\hline\
    Russia & 48,444 \\\\\\hline\
    Germany & 41,374 \\\\\\hline\
    Poland & 235,121 \\\\\\hline \\hline\
    \\textbf\{Total\} & \\textbf\{324,939\} \\\\\\hline\
  \\end\{tabular\}\
  \\caption\{Distribution per country of GSM cells where the changeable value is 0\}\
  \\label\{table:exact_GSM_distribution\}\
\\end\{table\}\
\
\\subsection\{Fetching the testdata\}\
When choosing the subsets to test our process on we keep a similar tactic as when testing it on theoretical data. We want to see how it behaves when different amounts of measurements are available per cell. One problem arised when downloading data by performing HTTP GET requests. The sample values of the cells in the downloadable database is in many cases not equal to the actual number of measurements available when performing HTTP GET requests. For example, if a cell in the downloadable database has the sample value 100, the actual amount of measurements we get for that cell when requesting it through HTTP may be 500. This means it is difficult to request cells with the intended amount of measurements. In addition to this, the maximum number of measurements that can be retrieved for a cell thrugh HTTP is 1000.\
\
Before we use the data we need to clean it up. The OpenCellID database contain a lot of bad measurements. First, we look at the location of where the measurement was measured. A cell can not broadcast infinitely far, and some measurements are too far away from the cell tower it belongs to for it to be valid.  See for an example figure \\ref\{fig:badMeasurementLocation\}. Macro-cell is the type of cell with the strongest broadcasting capabilities. The standard range of the macro-cell is 35km \\cite\{maxRange\} so we use this range as a threshold when validating a measurement's distance to the cell tower.\
\
\\begin\{figure\}[h!]\
\
\\centering\
\\includegraphics[scale=0.6]\{pictures/realCell_badMeasLocation.png\}\
\\caption\{A cell in Poland with one measurement in Libya\}\
\\label\{fig:badMeasurementLocation\}\
\\end\{figure\}\
\
Secondly, we need to validate each measurement's signal strength. This is only necessary when we are using RSS to compute $\\vec\{v\}_\{direction\}$. As described in table \\ref\{table:measurement\} the signal strength of a measurement is in either dBm or as defined in \\cite[section 8.5]\{TS127007\}. The dBm value of cell signals is always negative. \\cite[section 8.5]\{TS127007\} defines a mapping from the negative dBm values to positive numbers. See table \\ref\{table:signalStrengthMapping\}.\
\
\\begin\{table\}[h!]\
  \\center\
  \\begin\{tabular\}\{|c|c|\}\
    \\hline\
    \\cellcolor[gray]\{0.9\}\\cite[section 8.5]\{TS127007\}&\\cellcolor[gray]\{0.9\}dBm\\\\\\hline\
    0 & -113 dBm or less \\\\\\hline\
    1 & -111 dBm \\\\\\hline\
    2...30 & -109...-53 dBm \\\\\\hline\
    31 & -51 dBm or greater \\\\\\hline\
    99 & not known or not detectable \\\\\\hline\
  \\end\{tabular\}\
  \\caption\{Signal strength mapping from negative dBm values to positive numbers\}\
  \\label\{table:signalStrengthMapping\}\
\\end\{table\}\
\
As we can see from table \\ref\{table:signalStrengthMapping\}, signal strength can have the positive values 0 to 31 in addition to negative values. Measurements with signal strength values larger than 31 will not be considered valid. When running our process on data that includes measurements with signal strength values from 0 to 31, we translate these to dBm values. The formula is simple. If $x$ is a positive signal strength value not smaller than 0 and not larger than 31, the dBm value of $x$ can be calculated like this: $(2\\times x)-113$.\
\
We also need to consider the total number of different RSS values among every measurement belonging to a cell. If we are using RSS to compute $\\vec\{v\}_\{direction\}$ we need at least two different RSS values among the measurements. Since the pairing of measurements in algorithm 1 is done randomly we may need more than two different RSS values, especially when $n$ is small. That is why we use 3 as a threshold when validationg the different signal strength values among a cell's measurements.\
\
\\subsection\{Testdata of Exact Cells\}\
We ended up with a subset containing 2036 random cells with exact cell tower positions. The amount of measurements among the cells ranges from approximately 50 to 1000.\
\
\\subsection\{Testdata of Non-Exact Cells\}\
\
\
\
\\section\{Visualizing with Leaflet\}\
\
\\section\{Results\}\
\\textit\{Her vil jeg liste resultater paa samme maate som under Developing the Process, men paa ekte data. Her tenker jeg og aa inkorporere en del diskusjon. Satser paa aa vaere ferdig med dette i slutten av april.\}\
\
We will now start listing the initial results from running our process on real data with exact cell tower positions. We will run the process with both RSS and distance as parameters when generating $\\vec\{v\}_\{direction\}$. For comparison purposes we will also show the error when computing the cell tower position by calculating the average longitude and latitude from the cells' measurements. Recall that this is method currently used by OpenCellId.\
\
\\subsection\{The Haversin Formula\}\
%bruker n\'e5r vi genererer error og for \'e5 utelukke measurements\
\
\
\
\
\
\
\
\\chapter\{Improving the Process\}\
\\textit\{Her vil jeg beskrive forbedringer etter aa ha testet paa ekte data. Her vil det ogsaa bli en del diskusjon. Dette kommer jeg til aa jobbe med i mai, men se an hvordan der ligger an hele veien aa dermed finne et passende sted aa runde av.\}\
\
\
\\newpage\
\\chapter\{Conclusion\}\
\
\\textit\{Dette vil bli noe av det siste jeg skriver ettersom det blir vanskelig aa si helt sikkert hva som skal inn her paa dette tidspunktet\}\
\
\\section\{Status Summary\}\
\\textit\{Kjapp oppsummering\}\
\
\
\\section\{Future work\}\
\\textit\{Her vil jeg skrive om ytterligere forbedringer som kan gj\'f8res\}\
\
\\newpage\
%\\bibliographystyle\{abbrv\}\
%\\bibliography\{references\}\
\\addcontentsline\{toc\}\{chapter\}\{Bibliography\}\
\\printbibliography\
\
\\newpage\
\\appendix\
\\chapter\{Code\}\
\\textit\{Jeg tviler paa at jeg kommer til aa legge ved kode, men inkluderer likevel denne slik at vi ser hvordan det evt. vil se ut\}\
\\label\{app:code\}\
\\begin\{lstlisting\}\
package testdata;\
\
import java.awt.geom.Point2D;\
import java.util.Random;\
\
public class Measurement \{\
	\
	private Point2D.Double coordinates;\
	\
	// Signal Strength = sqrt((x2-x1)^2 + (y2-y1)^2) multiplied by -1 to achieve realistic dBm\
	private int signalStrength;\
	\
	// Weight = 113 - (-1 * Signal Strength)\
	private int weight;\
	\
	public Measurement(double longitude, double latitude) \{\
		this.coordinates = new Point2D.Double(longitude, latitude);\
		this.signalStrength = 99;\
		this.weight = -99;\
	\}\
\
	public Point2D.Double getCoordinates() \{\
		return coordinates;\
	\}\
\
	public void setCoordinates(Point2D.Double coordinates) \{\
		this.coordinates = coordinates;\
	\}\
\
	public int getSignalStrength() \{\
		return signalStrength;\
	\}\
\
	public void setSignalStrength(int signalStrength) \{\
		this.signalStrength = signalStrength;\
	\}\
\
	public int getWeight() \{\
		return weight;\
	\}\
\
	public void setWeight(int weight) \{\
		this.weight = weight;\
	\}\
\
	@Override\
	public String toString() \{\
		String s = String.format("Measurement coordinates: [%.1f,%.1f] - Signal Strength: %d dBm - Weight: %d", \
				this.coordinates.x, this.coordinates.y, this.signalStrength, this.weight);\
		return s;\
	\}\
\
	public static Measurement generateRandomMeasurement(int maxX, int maxY) \{\
		double x = (double) new Random().nextInt(maxX+1);\
		double y = (double) new Random().nextInt(maxY+1);\
		\
		return new Measurement(x, y);\
	\}\
\}\
\\end\{lstlisting\}\
\\end\{document\}}